# Введение в объекты:

Данный модуль содержит общие представления об ООП. Если вы не воспринимаете общей картины до тех пор, пока не увидите
детально как все работает, можете сразу перейти к следующей главе.

Позже все равно придется вернуться к данной главе, чтобы понять, почему так важны объекты и какое место они занимают при
проектировании программ.

## Объектно ориентированный подход

Позволяет представить задачу в пространстве путем введения "объектов". Объект обладает

1. Состоянием - внутренние данные
2. Поведением - методы
3. Индивидуальностью - уникальным адресом в памяти.

## Объект обладает интерфейсом

Объекты, идентичные во всем, кроме внутреннего состояния во время работы программы, группируются в _классы
объектов_ `class`.

Абстрактные типы данных действуют почти так же, как и встроенные типы: вы можете создавать переменные типов
(называемые объектами) и манипулировать ими (что называется посылкой сообщений; вы производите запрос, и объект решает,
что с ним делать).

Каждый объект принадлежит к определенному АТД или `class`, который определяет его характеристики и поведение. Когда
видите слово _класс_, думайте _тип_, и наоборот.

Каждый объект умеет выполнять только определенный круг запросов. Запросы, которые вы можете посылать объекту,
определяются его интерфейсом, причем интерфейс объекта определяется его типом.

![](Light.png)

```java
Light lt = new Light();
lt.on();
```

Интерфейс определяет, с какими запросами можно обращаться к определенному объекту. Однако где-то должен существовать и 
код, выполняющий запросы. Этот код наряду со скрытыми данными составляет реализацию. 

В данном примере существует тип/класс с именем `Light` (лампа), конкретный объект типа `Light` с именем `lt`, и класс 
поддерживает различные запросы к объекту `Light`: выключить лампочку, включить, сделать ярче или притушить. 
Вы создаете объект `Light`, определяя «ссылку» на него `lt` и вызывая оператор new для создания нового экземпляра этого типа. 
Чтобы послать сообщение объекту, следует указать имя объекта и связать его с помощью точки с нужным запросом.

---

- [Абстра́ктный тип да́нных(АТД)](https://ru.wikipedia.org/wiki/Абстрактный_тип_данных) — это математическая модель для
  типов данных, где тип данных определяется поведением (семантикой)с точки зрения пользователя данных, а именно в
  терминах возможных значений, возможных операций над данными этого типа и поведения этих операций.

- Некоторые специалисты различают эти два понятия: они считают, что тип определяет интерфейс, а класс — конкретную
  реализацию этого интерфейса.

## Скрытая реализация

Программистов имеет смысл разделить на создателей классов и программистов-клиентов. Цель вторых — собрать как можно 
больше классов, чтобы заниматься быстрой разработкой программ. Цель создателя класса — построить класс, открывающий 
только то, что необходимо программисту-клиенту, и скрывающий все остальное. 

Есть две основные причины для ограничения доступа:
1. Необходимость уберечь «хрупкие» детали от программиста-клиента — части внутренней «кухни», не являющиеся составляющими 
интерфейса, при помощи которого пользователи решают свои задачи.
2. Стремление позволить разработчику библиотеки изменить внутренние механизмы класса, не беспокоясь о том, как это 
отразится на программисте-клиенте.

Java использует три явных ключевых слова, характеризующих уровень доступа: public, private и protected, также есть 
доступ по умолчанию: default - доступом в пределах пакета.

## Повторное использование реализации

Многократное использование кода — одно из самых впечатляющих преимуществ объектно-ориентированных языков. Есть
несколько способов для повторного использования кода:
1. Композиция - размещение объекта внутрь нового класса
2. Наследование - создание класса на основе другого класса

### Композиция

Новый класс может содержать любое количество объектов других типов. Композицию часто называют связью типа 
«содержит» (has-a), как, например, в предложении «машина содержит двигатель».

Композиция — очень гибкий инструмент. Объекты-члены вашего нового класса обычно объявляются закрытыми (private), что делает 
их недоступными для программистов-клиентов. Это позволяет вносить изменения в эти объекты-члены без модификации уже 
существующего клиентского кода. Вы можете также изменять эти члены во время исполнения программы, чтобы динамически 
управлять поведением вашей программы.

### Наследование

Не имеет такой гибкости, так как компилятор накладывает определенные ограничения на классы, созданные с применением наследования.
При создании новых классов прежде всего следует оценить возможность композиции, так как она проще и гибче.

Было бы неэффективно создавать какой-то класс, а потом проделывать всю работу заново для похожего класса. Гораздо 
рациональнее взять готовый класс, «клонировать» его, а затем внести добавления и обновления в полученном клоне. Если 
базовый (родительский) класс изменяется, то все изменения отражаются и на его производном (дочернем) классе.

Базовый тип содержит все характеристики и действия, общие для всех типов, производных от него. Вы создаете базовый тип, 
чтобы заложить основу своего представления о каких-то объектах в вашей системе. От базового типа порождаются другие типы, 
выражающие другие реализации этой сущности.

Используя наследование от существующего типа, вы создаете новый тип. Этот новый тип содержит не только все члены 
существующего типа (хотя члены со спецификатором `private` скрыты и недоступны), но, что еще важнее, повторяет интерфейс 
базового класса. Значит, все сообщения, которые вы могли посылать базовому классу, также можно посылать и производному 
классу. А так как мы различаем типы классов по совокупности сообщений, которые можем им посылать, это означает, что 
производный класс является частным случаем базового класса.

Эквивалентность типов, достигаемая при наследовании, является одним из основополагающих условии понимания смысла 
объектно-ориентированного программирования.

Существует два способа изменения нового класса по сравнению с базовым классом:
1. Расширение производного класса новыми методами.
2. Изменение поведения уже существующих методов базового класса (переопределение).

## Взаимозаменяемые объекты и полиморфизм

При использовании иерархий типов часто приходится обращаться с объектом определенного типа как с базовым типом. Это 
позволяет писать код, не зависящий от конкретных типов.

Когда посылается сообщение, программист и не хочет знать, какой код выполняется, объект сам выполнит верный код, 
зависящий от его характерного типа. Если компилятор не обладает информацией, какой именно код следует выполнить, что же он делает?

Для решения этой задачи языки объектно-ориентированного программирования используют концепцию _позднего связывания_. 
Когда вы посылаете сообщение объекту, вызываемый код неизвестен вплоть до времени исполнения. Компилятор лишь 
убеждается в том, что метод существует, проверяет типы для его параметров и возвращаемого значения, но не имеет 
представления, какой именно код будет исполняться.

Для осуществления _позднего связывания_ Java вместо абсолютного вызова использует специальные фрагменты кода. 
Этот код вычисляет адрес тела метода на основе информации, хранящейся в объекте. 

```java
void doSomething(Shape shape) {
    shape.erase(); // стереть
    // ...
    shape.draw(); // нарисовать
}

Circle circle = new Circle(); // окружность 
Triangle triangle = new Triangle(); // треугольник 
Line line = new Line(); // линия
doSomething(circle);
doSomething(triangle);
doSomething(line);
```

Вызовы метода `doSomething()` автоматически работают правильно, вне зависимости от фактического типа объекта. 
На самом деле это довольно важный факт. Рассмотрим строку: `doSomething(c)j`

Здесь происходит следующее: методу, ожидающему объект `Shape`, передается объект «окружность» `Circle`. Так как 
окружность `Circle` одновременно является фигурой `Shape`, то метод `doSomething()` и обращается с ней как с фигурой. 
Другими словами, любое сообщение, которое метод может послать `Shape`, также принимается и `Circle`. Это действие совершенно 
безопасно и настолько же логично.

Мы называем этот процесс обращения с производным типом как с базовым восходящим преобразованием типов. Слово 
преобразование означает, что объект трактуется как принадлежащий к другому типу, а восходящее оно потому, что на 
диаграммах наследования базовые классы обычно располагаются вверху, а производные классы располагаются внизу «веером». 
Значит, преобразование к базовому типу — это движение по диаграмме вверх, и поэтому оно «восходящее».

![](upwardСonversion.png)


При вызовах функций, созданных не ООП-компилятором, используется _раннее связывание_. При раннем связывании
компилятор генерирует вызов функции с указанным именем, а компоновщик привязывает этот вызов к абсолютному адресу кода, 
который необходимо выполнить.


## Однокорневая иерархия

В основе всей иерархии типов лежит единый базовый класс Object. Оказалось, что однокорневая иерархия имеет множество преимуществ.
1. Все объекты имеют некий общий интерфейс
2. Все объекты гарантированно обладают некоторой общей функциональностью.
3. Позволяет гораздо проще реализовать уборку мусора
## Контейнеры

## Параметризованные типы

## Создание и время жизни объектов

## Обработка исключений: борьба с ошибками

## Параллельное выполнение

## Java и Интернет

### Что такое Web?

#### Вычисления «клиент сервер»

#### Web как гигантский сервер

### Программирование на стороне клиента

#### Языки сценариев

#### Java

#### Интернет и интрасети

### Программирование на стороне сервера

## Резюме